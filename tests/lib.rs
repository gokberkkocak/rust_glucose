#[cfg(test)]
mod tests {

    use std::fs::File;
    use std::io::{BufRead, BufReader};

    use rust_glucose::bindings::CGlucose;
    use rust_glucose::init_glucose_solver;
    use rust_glucose::add_clause_to_glucose_solver;
    use rust_glucose::run_glucose;
    use rust_glucose::get_glucose_solution;
    use rust_glucose::get_glucose_solution_no_malloc;

    #[test]
    pub fn test_solver_get_solution_1(){
        let solver = init_glucose_solver();
        let nb_v = parse_dimacs("tests/test.cnf", solver);
        let ret = run_glucose(solver);
        match ret {
            0 => { 
                let expected_sol = vec![1, 2, 3, -4, -5, 6, 7, -8, 9, 10, -11, -12, -13, -14, -15, -16, 17, 18, 19, -20, -21, -22, -23, -24, -25, 26, 27, 28, 29, -30, 31, -32, -33, 34, 35, 36, -37, -38, -39, -40, 41, 42, -43, 44, 45, 46, -47, 48, -49, 50, -51, 52, -53, 54, -55, 56, -57, -58, -59, -60, -61, -62, -63, -64, -65, -66, -67, -68, -69, -70, -71, -72, -73, -74, -75, -76, -77, -78, -79, -80, -81, 82, 83, 84, -85, 86, -87, 88, -89, 90, -91, 92, -93, -94, -95, -96, -97, -98, 99, 100, -101, -102, -103, -104, -105, -106, -107, -108, -109, -110, -111, -112, -113, -114, -115, -116, -117, -118, -119, -120, -121, 122, 123, 124, -125, 126, -127, 128, -129, -130, 131, 132, 133, -134, 135, -136, -137, -138, -139, -140, -141, 142, 143, 144, -145, 146, -147, 148, -149, 150, -151, -152, -153, -154, 155, 156, 157, -158, -159, -160, -161, -162, -163, 164, 165, 166, -167, -168, -169, -170, 171, 172, 173, -174, -175, -176, -177, -178, -179, 180, 181, 182, -183, 184, -185, 186, -187, -188, 189, 190, 191, -192, 193, -194, -195, -196, -197, -198, -199, 200, 201, 202, -203, -204, -205, -206, 207, 208, 209, -210, -211, -212, -213, -214, -215, -216, -217, -218, -219, 220, 221, 222, -223, -224, 225, 226, 227, -228, 229, -230, -231, -232, 233, 234, -235, 236, -237, 238, -239, 240, -241, 242, -243, 244, -245, -246, -247, -248, -249, -250, -251, -252, -253, -254, -255, -256, -257, 258, 259, 260, -261, -262, -263, -264, 265, 266, 267, -268, -269, 270, 271, 272, -273, 274, -275, 276, -277, 278, -279, 280, -281, -282, -283, -284, -285, -286, 287, 288, -289, -290, -291, -292, -293, 294, 295, 296, -297, -298, -299, -300, 301, 302, 303, -304, -305, -306, -307, -308, -309, 310, 311, 312, -313, 314, -315, 316, -317, -318, 319, 320, 321, -322, 323, -324, 325, -326, -327, 328, 329, 330, -331];
                let sol = get_glucose_solution(solver, nb_v); 
                assert_eq!(sol, expected_sol);
            },
            _ => panic!("Solution assertion failed."),
        }
    }

    #[test]
    pub fn test_solver_get_solution_2(){
        let solver = init_glucose_solver();
        let nb_v = parse_dimacs("tests/test.cnf", solver);
        let ret = run_glucose(solver);
        match ret {
            0 => { 
                let expected_sol = vec![1, 2, 3, -4, -5, 6, 7, -8, 9, 10, -11, -12, -13, -14, -15, -16, 17, 18, 19, -20, -21, -22, -23, -24, -25, 26, 27, 28, 29, -30, 31, -32, -33, 34, 35, 36, -37, -38, -39, -40, 41, 42, -43, 44, 45, 46, -47, 48, -49, 50, -51, 52, -53, 54, -55, 56, -57, -58, -59, -60, -61, -62, -63, -64, -65, -66, -67, -68, -69, -70, -71, -72, -73, -74, -75, -76, -77, -78, -79, -80, -81, 82, 83, 84, -85, 86, -87, 88, -89, 90, -91, 92, -93, -94, -95, -96, -97, -98, 99, 100, -101, -102, -103, -104, -105, -106, -107, -108, -109, -110, -111, -112, -113, -114, -115, -116, -117, -118, -119, -120, -121, 122, 123, 124, -125, 126, -127, 128, -129, -130, 131, 132, 133, -134, 135, -136, -137, -138, -139, -140, -141, 142, 143, 144, -145, 146, -147, 148, -149, 150, -151, -152, -153, -154, 155, 156, 157, -158, -159, -160, -161, -162, -163, 164, 165, 166, -167, -168, -169, -170, 171, 172, 173, -174, -175, -176, -177, -178, -179, 180, 181, 182, -183, 184, -185, 186, -187, -188, 189, 190, 191, -192, 193, -194, -195, -196, -197, -198, -199, 200, 201, 202, -203, -204, -205, -206, 207, 208, 209, -210, -211, -212, -213, -214, -215, -216, -217, -218, -219, 220, 221, 222, -223, -224, 225, 226, 227, -228, 229, -230, -231, -232, 233, 234, -235, 236, -237, 238, -239, 240, -241, 242, -243, 244, -245, -246, -247, -248, -249, -250, -251, -252, -253, -254, -255, -256, -257, 258, 259, 260, -261, -262, -263, -264, 265, 266, 267, -268, -269, 270, 271, 272, -273, 274, -275, 276, -277, 278, -279, 280, -281, -282, -283, -284, -285, -286, 287, 288, -289, -290, -291, -292, -293, 294, 295, 296, -297, -298, -299, -300, 301, 302, 303, -304, -305, -306, -307, -308, -309, 310, 311, 312, -313, 314, -315, 316, -317, -318, 319, 320, 321, -322, 323, -324, 325, -326, -327, 328, 329, 330, -331];
                let mut sol = Vec::with_capacity(nb_v);
                get_glucose_solution_no_malloc(solver, &mut sol, nb_v);
                assert_eq!(sol, expected_sol);
            },
            _ => panic!("Solution assertion failed."),
        }
    }

    fn parse_dimacs(path: &str, solver : *mut CGlucose) -> usize {
        let input = File::open(path).unwrap();
        let buffered = BufReader::new(input);
        let mut _nb_c: usize;
        let mut nb_v: usize = 0;
        for line in buffered.lines() {
            let l = line.unwrap();
            if l.contains("p") && l.contains("cnf") {
                let i : Vec<&str> = l.split_whitespace().collect();
                nb_v = i[2].to_string().parse().unwrap();
                _nb_c = i[3].to_string().parse().unwrap();
            }
            else if l.is_empty() || l.contains("c") {
                continue;
            }  else {
                let iter = l.split_whitespace();
                let mut v_clause : Vec<i32> = vec![];
                'iter: for i in iter {
                    let int: i32 = i.parse().unwrap();
                    if int == 0 {
                        break 'iter;
                    }
                    v_clause.push(int);
                }
                add_clause_to_glucose_solver(solver, v_clause);
            }
        }
        nb_v
    }
}